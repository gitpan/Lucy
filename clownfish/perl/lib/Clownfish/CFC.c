/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2202 from the
 * contents of CFC.xs. Do not edit this file, edit CFC.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "lib/Clownfish/CFC.xs"
/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "CFC.h"

/* Rather than provide an XSUB for each accessor, we can use one multipath
 * accessor function per class, with several Perl-space aliases.  All set
 * functions have odd-numbered aliases, and all get functions have
 * even-numbered aliases.  These two macros serve as bookends for the switch
 * function.
 */
#define START_SET_OR_GET_SWITCH \
    SV *retval = &PL_sv_undef; \
    /* If called as a setter, make sure the extra arg is there. */ \
    if (ix % 2 == 1) { \
        if (items != 2) { croak("usage: $object->set_xxxxxx($val)"); } \
    } \
    else { \
        if (items != 1) { croak("usage: $object->get_xxxxx()"); } \
    } \
    switch (ix) {

#define END_SET_OR_GET_SWITCH \
        default: croak("Internal error. ix: %d", (int)ix); \
    } \
    if (ix % 2 == 0) { \
        XPUSHs(sv_2mortal(retval)); \
        XSRETURN(1); \
    } \
    else { \
        XSRETURN(0); \
    }

static SV*
S_cfcbase_to_perlref(void *thing) {
    SV *ref = newSV(0);
    if (thing) {
        const char *klass = CFCBase_get_cfc_class((CFCBase*)thing);
        CFCBase_incref((CFCBase*)thing);
        sv_setref_pv(ref, klass, (void*)thing);
    }
    return ref;
}

// Transform a NULL-terminated array of CFCBase* into a Perl arrayref.
static SV*
S_array_of_cfcbase_to_av(CFCBase **things) {
    AV *av = newAV();
    size_t i;
    for (i = 0; things[i] != NULL; i++) {
        SV *val = S_cfcbase_to_perlref(things[i]);
        av_store(av, i, val);
    }
    SV *retval = newRV((SV*)av);
    SvREFCNT_dec(av);
    return retval;
}

static SV*
S_sv_eat_c_string(char *string) {
    if (string) {
        SV *sv = newSVpvn(string, strlen(string));
        FREEMEM(string);
        return sv;
    }
    else {
        return newSV(0);
    }
}

#line 98 "lib/Clownfish/CFC.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 150 "lib/Clownfish/CFC.c"

XS(XS_Clownfish__CFC__Base_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Base_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCBase *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Base")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCBase *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Base");
	};
#line 94 "lib/Clownfish/CFC.xs"
    CFCBase_decref((CFCBase*)self);
#line 179 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__CBlock__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__CBlock__new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "contents");
    {
	const char *	contents = (const char *)SvPV_nolen(ST(0));
	SV *	RETVAL;
#line 103 "lib/Clownfish/CFC.xs"
    CFCCBlock *self = CFCCBlock_new(contents);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 203 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__CBlock__set_or_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__CBlock__set_or_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCCBlock *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::CBlock")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCCBlock *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::CBlock");
	};
#line 114 "lib/Clownfish/CFC.xs"
{
    START_SET_OR_GET_SWITCH
        case 2: {
                const char *contents = CFCCBlock_get_contents(self);
                retval = newSVpvn(contents, strlen(contents));
            }
            break;
    END_SET_OR_GET_SWITCH
}
#line 247 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Class__create); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class__create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 10)
       croak_xs_usage(cv,  "parcel, exposure_sv, class_name_sv, cnick_sv, micro_sym_sv, docucomment, source_class_sv, parent_class_name_sv, is_final, is_inert");
    {
	CFCParcel *	parcel;
	SV *	exposure_sv = ST(1);
	SV *	class_name_sv = ST(2);
	SV *	cnick_sv = ST(3);
	SV *	micro_sym_sv = ST(4);
	CFCDocuComment *	docucomment;
	SV *	source_class_sv = ST(6);
	SV *	parent_class_name_sv = ST(7);
	bool	is_final = (bool)SvTRUE(ST(8));
	bool	is_inert = (bool)SvTRUE(ST(9));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        parcel = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		parcel = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};

	if (!SvOK(ST(5))) {
        docucomment = NULL;
    }
	else if (sv_derived_from(ST(5), "Clownfish::CFC::DocuComment")) {
		IV objint = SvIV((SV*)SvRV(ST(5)));
		docucomment = INT2PTR(CFCDocuComment *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::DocuComment");
	};
#line 139 "lib/Clownfish/CFC.xs"
    const char *exposure =
        SvOK(exposure_sv) ? SvPV_nolen(exposure_sv) : NULL;
    const char *class_name =
        SvOK(class_name_sv) ? SvPV_nolen(class_name_sv) : NULL;
    const char *cnick =
        SvOK(cnick_sv) ? SvPV_nolen(cnick_sv) : NULL;
    const char *micro_sym =
        SvOK(micro_sym_sv) ? SvPV_nolen(micro_sym_sv) : NULL;
    const char *source_class =
        SvOK(source_class_sv) ? SvPV_nolen(source_class_sv) : NULL;
    const char *parent_class_name =
        SvOK(parent_class_name_sv) ? SvPV_nolen(parent_class_name_sv) : NULL;
    CFCClass *self = CFCClass_create(parcel, exposure, class_name, cnick,
                                     micro_sym, docucomment, source_class,
                                     parent_class_name, is_final, is_inert);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 316 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Class__fetch_singleton); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class__fetch_singleton)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "parcel, class_name");
    {
	CFCParcel *	parcel;
	const char *	class_name = (const char *)SvPV_nolen(ST(1));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        parcel = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		parcel = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};
#line 163 "lib/Clownfish/CFC.xs"
    CFCClass *klass = CFCClass_fetch_singleton(parcel, class_name);
    RETVAL = S_cfcbase_to_perlref(klass);
#line 352 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Class__clear_registry); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class__clear_registry)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 170 "lib/Clownfish/CFC.xs"
    CFCClass_clear_registry();
#line 374 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Class_append_autocode); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class_append_autocode)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, autocode");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCClass *	self;
	const char *	autocode = (const char *)SvPV_nolen(ST(1));

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};
#line 177 "lib/Clownfish/CFC.xs"
    CFCClass_append_autocode(self, autocode);
#line 409 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Class_add_child); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class_add_child)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, child");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCClass *	self;
	CFCClass *	child;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};

	if (!SvOK(ST(1))) {
        child = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		child = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};
#line 184 "lib/Clownfish/CFC.xs"
    CFCClass_add_child(self, child);
#line 455 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Class_add_member_var); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class_add_member_var)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, var");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCClass *	self;
	CFCVariable *	var;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};

	if (!SvOK(ST(1))) {
        var = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Variable")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		var = INT2PTR(CFCVariable *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Variable");
	};
#line 191 "lib/Clownfish/CFC.xs"
    CFCClass_add_member_var(self, var);
#line 501 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Class_add_function); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class_add_function)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, func");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCClass *	self;
	CFCFunction *	func;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};

	if (!SvOK(ST(1))) {
        func = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Function")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		func = INT2PTR(CFCFunction *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Function");
	};
#line 198 "lib/Clownfish/CFC.xs"
    CFCClass_add_function(self, func);
#line 547 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Class_add_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class_add_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, method");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCClass *	self;
	CFCMethod *	method;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};

	if (!SvOK(ST(1))) {
        method = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		method = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};
#line 205 "lib/Clownfish/CFC.xs"
    CFCClass_add_method(self, method);
#line 593 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Class_add_attribute); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class_add_attribute)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "self, name, value_sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCClass *	self;
	const char *	name = (const char *)SvPV_nolen(ST(1));
	SV *	value_sv = ST(2);

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};
#line 213 "lib/Clownfish/CFC.xs"
    char *value = SvOK(value_sv) ? SvPV_nolen(value_sv) : NULL;
    CFCClass_add_attribute(self, name, value);
#line 630 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Class_has_attribute); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class_has_attribute)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, name");
    {
	CFCClass *	self;
	const char *	name = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};
#line 221 "lib/Clownfish/CFC.xs"
    RETVAL = CFCClass_has_attribute(self, name);
#line 665 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Class_grow_tree); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class_grow_tree)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCClass *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};
#line 228 "lib/Clownfish/CFC.xs"
    CFCClass_grow_tree(self);
#line 699 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Class_add_inert_var); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class_add_inert_var)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, var");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCClass *	self;
	CFCVariable *	var;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};

	if (!SvOK(ST(1))) {
        var = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Variable")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		var = INT2PTR(CFCVariable *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Variable");
	};
#line 235 "lib/Clownfish/CFC.xs"
    CFCClass_add_inert_var(self, var);
#line 745 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Class_function); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class_function)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, sym");
    {
	CFCClass *	self;
	const char *	sym = (const char *)SvPV_nolen(ST(1));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};
#line 242 "lib/Clownfish/CFC.xs"
    CFCFunction *func = CFCClass_function(self, sym);
    RETVAL = S_cfcbase_to_perlref(func);
#line 780 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Class_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, sym");
    {
	CFCClass *	self;
	const char *	sym = (const char *)SvPV_nolen(ST(1));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};
#line 251 "lib/Clownfish/CFC.xs"
    CFCMethod *method = CFCClass_method(self, sym);
    RETVAL = S_cfcbase_to_perlref(method);
#line 816 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Class_novel_method); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class_novel_method)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, sym");
    {
	CFCClass *	self;
	const char *	sym = (const char *)SvPV_nolen(ST(1));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};
#line 260 "lib/Clownfish/CFC.xs"
    CFCMethod *method = CFCClass_novel_method(self, sym);
    RETVAL = S_cfcbase_to_perlref(method);
#line 852 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Class__set_or_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Class__set_or_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCClass *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};
#line 293 "lib/Clownfish/CFC.xs"
{
    START_SET_OR_GET_SWITCH
        case 2: {
                const char *value = CFCClass_get_cnick(self);
                retval = newSVpvn(value, strlen(value));
            }
            break;
        case 5: {
                CFCClass *parent = NULL;
                if (SvOK(ST(1))
                    && sv_derived_from(ST(1), "Clownfish::CFC::Class")
                   ) {
                    IV objint = SvIV((SV*)SvRV(ST(1)));
                    parent = INT2PTR(CFCClass*, objint);
                }
                CFCClass_set_parent(self, parent);
                break;
            }
        case 6: {
                CFCClass *parent = CFCClass_get_parent(self);
                retval = S_cfcbase_to_perlref(parent);
                break;
            }
        case 8: {
                const char *value = CFCClass_get_autocode(self);
                retval = newSVpvn(value, strlen(value));
            }
            break;
        case 10: {
                const char *value = CFCClass_get_source_class(self);
                retval = newSVpvn(value, strlen(value));
            }
            break;
        case 12: {
                const char *value = CFCClass_get_parent_class_name(self);
                retval = value ? newSVpvn(value, strlen(value)) : newSV(0);
            }
            break;
        case 14:
            retval = newSViv(CFCClass_final(self));
            break;
        case 16:
            retval = newSViv(CFCClass_inert(self));
            break;
        case 18: {
                const char *value = CFCClass_get_struct_sym(self);
                retval = value ? newSVpvn(value, strlen(value)) : newSV(0);
            }
            break;
        case 20: {
                const char *value = CFCClass_full_struct_sym(self);
                retval = value ? newSVpvn(value, strlen(value)) : newSV(0);
            }
            break;
        case 22: {
                const char *value = CFCClass_short_vtable_var(self);
                retval = value ? newSVpvn(value, strlen(value)) : newSV(0);
            }
            break;
        case 24: {
                const char *value = CFCClass_full_vtable_var(self);
                retval = value ? newSVpvn(value, strlen(value)) : newSV(0);
            }
            break;
        case 26: {
                const char *value = CFCClass_full_vtable_type(self);
                retval = value ? newSVpvn(value, strlen(value)) : newSV(0);
            }
            break;
        case 28: {
                const char *value = CFCClass_include_h(self);
                retval = value ? newSVpvn(value, strlen(value)) : newSV(0);
            }
            break;
        case 30: {
                CFCDocuComment *docucomment = CFCClass_get_docucomment(self);
                retval = S_cfcbase_to_perlref(docucomment);
            }
            break;
        case 32:
            retval = S_array_of_cfcbase_to_av(
                (CFCBase**)CFCClass_children(self));
            break;
        case 34:
            retval = S_array_of_cfcbase_to_av((CFCBase**)CFCClass_functions(self));
            break;
        case 36:
            retval = S_array_of_cfcbase_to_av((CFCBase**)CFCClass_methods(self));
            break;
        case 38:
            retval = S_array_of_cfcbase_to_av((CFCBase**)CFCClass_member_vars(self));
            break;
        case 40:
            retval = S_array_of_cfcbase_to_av((CFCBase**)CFCClass_inert_vars(self));
            break;
        case 42: {
                CFCClass **ladder = CFCClass_tree_to_ladder(self);
                retval = S_array_of_cfcbase_to_av((CFCBase**)ladder);
                FREEMEM(ladder);
                break;
            }
        case 44: {
                CFCMethod **novel = CFCClass_novel_methods(self);
                retval = S_array_of_cfcbase_to_av((CFCBase**)novel);
                FREEMEM(novel);
                break;
            }
        case 46: {
                CFCVariable **novel = CFCClass_novel_member_vars(self);
                retval = S_array_of_cfcbase_to_av((CFCBase**)novel);
                FREEMEM(novel);
                break;
            }
        case 48: {
                const char *value = CFCClass_privacy_symbol(self);
                retval = value ? newSVpvn(value, strlen(value)) : newSV(0);
            }
            break;
    END_SET_OR_GET_SWITCH
}
#line 1007 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__DocuComment_parse); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__DocuComment_parse)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "klass, text");
    {
	const char *	klass = (const char *)SvPV_nolen(ST(0));
	const char *	text = (const char *)SvPV_nolen(ST(1));
	SV *	RETVAL;
#line 422 "lib/Clownfish/CFC.xs"
    if (strcmp(klass, "Clownfish::CFC::DocuComment")) {
        croak("No subclassing allowed");
    }
    CFCDocuComment *self = CFCDocuComment_parse(text);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 1035 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__DocuComment__set_or_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__DocuComment__set_or_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCDocuComment *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::DocuComment")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCDocuComment *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::DocuComment");
	};
#line 441 "lib/Clownfish/CFC.xs"
{
    START_SET_OR_GET_SWITCH
        case 2: {
                const char *description = CFCDocuComment_get_description(self);
                retval = newSVpvn(description, strlen(description));
            }
            break;
        case 4: {
                const char *brief = CFCDocuComment_get_brief(self);
                retval = newSVpvn(brief, strlen(brief));
            }
            break;
        case 6: {
                const char *long_description = CFCDocuComment_get_long(self);
                retval = newSVpvn(long_description, strlen(long_description));
            }
            break;
        case 8: {
                AV *av = newAV();
                const char **names = CFCDocuComment_get_param_names(self);
                size_t i;
                for (i = 0; names[i] != NULL; i++) {
                    SV *val_sv = newSVpvn(names[i], strlen(names[i]));
                    av_store(av, i, val_sv);
                }
                retval = newRV((SV*)av);
                SvREFCNT_dec(av);
                break;
            }
        case 10: {
                AV *av = newAV();
                const char **docs = CFCDocuComment_get_param_docs(self);
                size_t i;
                for (i = 0; docs[i] != NULL; i++) {
                    SV *val_sv = newSVpvn(docs[i], strlen(docs[i]));
                    av_store(av, i, val_sv);
                }
                retval = newRV((SV*)av);
                SvREFCNT_dec(av);
                break;
            }
        case 12: {
                const char *rv = CFCDocuComment_get_retval(self);
                retval = rv ? newSVpvn(rv, strlen(rv)) : newSV(0);
            }
            break;
    END_SET_OR_GET_SWITCH
}
#line 1118 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Dumpable_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Dumpable_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "klass");
    {
	const char *	klass = (const char *)SvPV_nolen(ST(0));
	SV *	RETVAL;
#line 496 "lib/Clownfish/CFC.xs"
    if (strcmp(klass, "Clownfish::CFC::Dumpable")) {
        croak("No subclassing allowed");
    }
    CFCDumpable *self = CFCDumpable_new();
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 1145 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Dumpable_add_dumpables); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Dumpable_add_dumpables)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, klass");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCDumpable *	self;
	CFCClass *	klass;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Dumpable")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCDumpable *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Dumpable");
	};

	if (!SvOK(ST(1))) {
        klass = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		klass = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};
#line 509 "lib/Clownfish/CFC.xs"
    CFCDumpable_add_dumpables(self, klass);
#line 1192 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__File__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__File__new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "source_class");
    {
	const char *	source_class = (const char *)SvPV_nolen(ST(0));
	SV *	RETVAL;
#line 518 "lib/Clownfish/CFC.xs"
    CFCFile *self = CFCFile_new(source_class);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 1216 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__File_add_block); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__File_add_block)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, block");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCFile *	self;
	CFCBase *	block;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::File")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCFile *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::File");
	};

	if (!SvOK(ST(1))) {
        block = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Base")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		block = INT2PTR(CFCBase *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Base");
	};
#line 528 "lib/Clownfish/CFC.xs"
    CFCFile_add_block(self, block);
#line 1263 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__File__set_or_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__File__set_or_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCFile *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::File")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCFile *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::File");
	};
#line 543 "lib/Clownfish/CFC.xs"
{
    START_SET_OR_GET_SWITCH
        case 1:
            CFCFile_set_modified(self, !!SvTRUE(ST(1)));
            break;
        case 2:
            retval = newSViv(CFCFile_get_modified(self));
            break;
        case 4: {
                const char *value = CFCFile_get_source_class(self);
                retval = newSVpv(value, strlen(value));
            }
            break;
        case 6: {
                const char *value = CFCFile_guard_name(self);
                retval = newSVpv(value, strlen(value));
            }
            break;
        case 8: {
                const char *value = CFCFile_guard_start(self);
                retval = newSVpv(value, strlen(value));
            }
            break;
        case 10: {
                const char *value = CFCFile_guard_close(self);
                retval = newSVpv(value, strlen(value));
            }
            break;
        case 12:
            retval = S_array_of_cfcbase_to_av(CFCFile_blocks(self));
            break;
        case 14:
            retval = S_array_of_cfcbase_to_av(
                         (CFCBase**)CFCFile_classes(self));
            break;
    END_SET_OR_GET_SWITCH
}
#line 1334 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__File__gen_path); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__File__gen_path)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "self, base_dir = NULL");
    {
	CFCFile *	self;
	const char *	base_dir;
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::File")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCFile *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::File");
	};

	if (items < 2)
	    base_dir = NULL;
	else {
	    base_dir = (const char *)SvPV_nolen(ST(1));
	}
#line 590 "lib/Clownfish/CFC.xs"
{
    size_t buf_size = CFCFile_path_buf_size(self, base_dir);
    RETVAL = newSV(buf_size);
    SvPOK_on(RETVAL);
    char *buf = SvPVX(RETVAL);
    switch (ix) {
        case 1:
            CFCFile_c_path(self, buf, buf_size, base_dir);
            break;
        case 2:
            CFCFile_h_path(self, buf, buf_size, base_dir);
            break;
        case 3:
            CFCFile_cfh_path(self, buf, buf_size, base_dir);
            break;
        default:
            croak("unexpected ix value: %d", (int)ix);
    }
    SvCUR_set(RETVAL, strlen(buf));
}
#line 1394 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Function__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Function__new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 9)
       croak_xs_usage(cv,  "parcel, exposure_sv, class_name_sv, class_cnick_sv, micro_sym_sv, return_type, param_list, docucomment, is_inline");
    {
	CFCParcel *	parcel;
	SV *	exposure_sv = ST(1);
	SV *	class_name_sv = ST(2);
	SV *	class_cnick_sv = ST(3);
	SV *	micro_sym_sv = ST(4);
	CFCType *	return_type;
	CFCParamList *	param_list;
	CFCDocuComment *	docucomment;
	int	is_inline = (int)SvIV(ST(8));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        parcel = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		parcel = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};

	if (!SvOK(ST(5))) {
        return_type = NULL;
    }
	else if (sv_derived_from(ST(5), "Clownfish::CFC::Type")) {
		IV objint = SvIV((SV*)SvRV(ST(5)));
		return_type = INT2PTR(CFCType *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Type");
	};

	if (!SvOK(ST(6))) {
        param_list = NULL;
    }
	else if (sv_derived_from(ST(6), "Clownfish::CFC::ParamList")) {
		IV objint = SvIV((SV*)SvRV(ST(6)));
		param_list = INT2PTR(CFCParamList *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::ParamList");
	};

	if (!SvOK(ST(7))) {
        docucomment = NULL;
    }
	else if (sv_derived_from(ST(7), "Clownfish::CFC::DocuComment")) {
		IV objint = SvIV((SV*)SvRV(ST(7)));
		docucomment = INT2PTR(CFCDocuComment *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::DocuComment");
	};
#line 627 "lib/Clownfish/CFC.xs"
    const char *exposure =
        SvOK(exposure_sv) ? SvPV_nolen(exposure_sv) : NULL;
    const char *class_name =
        SvOK(class_name_sv) ? SvPV_nolen(class_name_sv) : NULL;
    const char *class_cnick =
        SvOK(class_cnick_sv) ? SvPV_nolen(class_cnick_sv) : NULL;
    const char *micro_sym =
        SvOK(micro_sym_sv) ? SvPV_nolen(micro_sym_sv) : NULL;
    CFCFunction *self = CFCFunction_new(parcel, exposure, class_name,
                                        class_cnick, micro_sym, return_type,
                                        param_list, docucomment, is_inline);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 1481 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Function__set_or_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Function__set_or_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCFunction *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Function")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCFunction *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Function");
	};
#line 654 "lib/Clownfish/CFC.xs"
{
    START_SET_OR_GET_SWITCH
        case 2: {
                CFCType *type = CFCFunction_get_return_type(self);
                retval = S_cfcbase_to_perlref(type);
            }
            break;
        case 4: {
                CFCParamList *param_list = CFCFunction_get_param_list(self);
                retval = S_cfcbase_to_perlref(param_list);
            }
            break;
        case 6: {
                CFCDocuComment *docucomment
                    = CFCFunction_get_docucomment(self);
                retval = S_cfcbase_to_perlref(docucomment);
            }
            break;
        case 8:
            retval = newSViv(CFCFunction_inline(self));
            break;
        case 10:
            retval = newSViv(CFCFunction_void(self));
            break;
        case 12: {
                const char *full_sym = CFCFunction_full_func_sym(self);
                retval = newSVpv(full_sym, strlen(full_sym));
            }
            break;
        case 14: {
                const char *short_sym = CFCFunction_short_func_sym(self);
                retval = newSVpv(short_sym, strlen(short_sym));
            }
            break;
    END_SET_OR_GET_SWITCH
}
#line 1552 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Hierarchy__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Hierarchy__new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "source, dest");
    {
	const char *	source = (const char *)SvPV_nolen(ST(0));
	const char *	dest = (const char *)SvPV_nolen(ST(1));
	SV *	RETVAL;
#line 698 "lib/Clownfish/CFC.xs"
    CFCHierarchy *self = CFCHierarchy_new(source, dest);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 1577 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Hierarchy_build); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Hierarchy_build)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCHierarchy *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Hierarchy")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCHierarchy *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Hierarchy");
	};
#line 707 "lib/Clownfish/CFC.xs"
    CFCHierarchy_build(self);
#line 1612 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Hierarchy_propagate_modified); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Hierarchy_propagate_modified)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	CFCHierarchy *	self;
	int	RETVAL;
	dXSTARG;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Hierarchy")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCHierarchy *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Hierarchy");
	};
#line 713 "lib/Clownfish/CFC.xs"
    int modified = items > 1 ? !!SvTRUE(ST(1)) : 0;
    RETVAL = CFCHierarchy_propagate_modified(self, modified);
#line 1647 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Hierarchy__set_or_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Hierarchy__set_or_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCHierarchy *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Hierarchy")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCHierarchy *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Hierarchy");
	};
#line 726 "lib/Clownfish/CFC.xs"
{
    START_SET_OR_GET_SWITCH
        case 2: {
                const char *value = CFCHierarchy_get_source(self);
                retval = newSVpv(value, strlen(value));
            }
            break;
        case 4: {
                const char *value = CFCHierarchy_get_dest(self);
                retval = newSVpv(value, strlen(value));
            }
            break;
        case 8:
            retval = S_array_of_cfcbase_to_av(
                (CFCBase**)CFCHierarchy_files(self));
            break;
        case 10: {
                CFCClass **ladder = CFCHierarchy_ordered_classes(self);
                retval = S_array_of_cfcbase_to_av((CFCBase**)ladder);
                FREEMEM(ladder);
            }
            break;
    END_SET_OR_GET_SWITCH
}
#line 1705 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Method__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Method__new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 10)
       croak_xs_usage(cv,  "parcel, exposure_sv, class_name_sv, class_cnick_sv, macro_sym, return_type, param_list, docucomment, is_final, is_abstract");
    {
	CFCParcel *	parcel;
	SV *	exposure_sv = ST(1);
	SV *	class_name_sv = ST(2);
	SV *	class_cnick_sv = ST(3);
	const char *	macro_sym = (const char *)SvPV_nolen(ST(4));
	CFCType *	return_type;
	CFCParamList *	param_list;
	CFCDocuComment *	docucomment;
	int	is_final = (int)SvIV(ST(8));
	int	is_abstract = (int)SvIV(ST(9));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        parcel = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		parcel = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};

	if (!SvOK(ST(5))) {
        return_type = NULL;
    }
	else if (sv_derived_from(ST(5), "Clownfish::CFC::Type")) {
		IV objint = SvIV((SV*)SvRV(ST(5)));
		return_type = INT2PTR(CFCType *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Type");
	};

	if (!SvOK(ST(6))) {
        param_list = NULL;
    }
	else if (sv_derived_from(ST(6), "Clownfish::CFC::ParamList")) {
		IV objint = SvIV((SV*)SvRV(ST(6)));
		param_list = INT2PTR(CFCParamList *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::ParamList");
	};

	if (!SvOK(ST(7))) {
        docucomment = NULL;
    }
	else if (sv_derived_from(ST(7), "Clownfish::CFC::DocuComment")) {
		IV objint = SvIV((SV*)SvRV(ST(7)));
		docucomment = INT2PTR(CFCDocuComment *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::DocuComment");
	};
#line 767 "lib/Clownfish/CFC.xs"
    const char *exposure =
        SvOK(exposure_sv) ? SvPV_nolen(exposure_sv) : NULL;
    const char *class_name =
        SvOK(class_name_sv) ? SvPV_nolen(class_name_sv) : NULL;
    const char *class_cnick =
        SvOK(class_cnick_sv) ? SvPV_nolen(class_cnick_sv) : NULL;
    CFCMethod *self = CFCMethod_new(parcel, exposure, class_name, class_cnick,
                                    macro_sym, return_type, param_list,
                                    docucomment, is_final, is_abstract);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 1790 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Method_compatible); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Method_compatible)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, other");
    {
	CFCMethod *	self;
	CFCMethod *	other;
	int	RETVAL;
	dXSTARG;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};

	if (!SvOK(ST(1))) {
        other = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};
#line 785 "lib/Clownfish/CFC.xs"
    RETVAL = CFCMethod_compatible(self, other);
#line 1837 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Method_override); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Method_override)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, other");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCMethod *	self;
	CFCMethod *	other;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};

	if (!SvOK(ST(1))) {
        other = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};
#line 793 "lib/Clownfish/CFC.xs"
    CFCMethod_override(self, other);
#line 1883 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Method_finalize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Method_finalize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	CFCMethod *	self;
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};
#line 799 "lib/Clownfish/CFC.xs"
    CFCMethod *finalized = CFCMethod_finalize(self);
    RETVAL = S_cfcbase_to_perlref(finalized);
    CFCBase_decref((CFCBase*)finalized);
#line 1918 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Method__various_method_syms); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Method__various_method_syms)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "self, invoker");
    {
	CFCMethod *	self;
	const char *	invoker = (const char *)SvPV_nolen(ST(1));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};
#line 813 "lib/Clownfish/CFC.xs"
    size_t size = 0;
    switch (ix) {
        case 1:
            size = CFCMethod_short_method_sym(self, invoker, NULL, 0);
            break;
        case 2:
            size = CFCMethod_full_method_sym(self, invoker, NULL, 0);
            break;
        case 3:
            size = CFCMethod_full_offset_sym(self, invoker, NULL, 0);
            break;
        default: croak("Unexpected ix: %d", (int)ix);
    }
    RETVAL = newSV(size);
    SvPOK_on(RETVAL);
    char *buf = SvPVX(RETVAL);
    switch (ix) {
        case 1:
            CFCMethod_short_method_sym(self, invoker, buf, size);
            break;
        case 2:
            CFCMethod_full_method_sym(self, invoker, buf, size);
            break;
        case 3:
            CFCMethod_full_offset_sym(self, invoker, buf, size);
            break;
        default: croak("Unexpected ix: %d", (int)ix);
    }
    SvCUR_set(RETVAL, strlen(buf));
#line 1982 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Method__set_or_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Method__set_or_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCMethod *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};
#line 858 "lib/Clownfish/CFC.xs"
{
    START_SET_OR_GET_SWITCH
        case 2: {
                const char *macro_sym = CFCMethod_get_macro_sym(self);
                retval = newSVpvn(macro_sym, strlen(macro_sym));
            }
            break;
        case 4: {
                const char *short_typedef = CFCMethod_short_typedef(self);
                retval = newSVpvn(short_typedef, strlen(short_typedef));
            }
            break;
        case 6: {
                const char *value = CFCMethod_full_typedef(self);
                retval = newSVpvn(value, strlen(value));
            }
            break;
        case 8: {
                const char *value = CFCMethod_full_callback_sym(self);
                retval = newSVpvn(value, strlen(value));
            }
            break;
        case 10: {
                const char *value = CFCMethod_full_override_sym(self);
                retval = newSVpvn(value, strlen(value));
            }
            break;
        case 12:
            retval = newSViv(CFCMethod_abstract(self));
            break;
        case 14:
            retval = newSViv(CFCMethod_novel(self));
            break;
        case 16:
            retval = newSViv(CFCMethod_final(self));
            break;
        case 18: {
                CFCType *type = CFCMethod_self_type(self);
                retval = S_cfcbase_to_perlref(type);
            }
            break;
    END_SET_OR_GET_SWITCH
}
#line 2060 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__ParamList__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__ParamList__new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "klass, variadic");
    {
	int	variadic = (int)SvIV(ST(1));
	SV *	RETVAL;
#line 909 "lib/Clownfish/CFC.xs"
    CFCParamList *self = CFCParamList_new(variadic);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 2084 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__ParamList_add_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__ParamList_add_param)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "self, variable, value_sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCParamList *	self;
	CFCVariable *	variable;
	SV *	value_sv = ST(2);

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::ParamList")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCParamList *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::ParamList");
	};

	if (!SvOK(ST(1))) {
        variable = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Variable")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		variable = INT2PTR(CFCVariable *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Variable");
	};
#line 920 "lib/Clownfish/CFC.xs"
    const char *value = SvOK(value_sv) ? SvPV_nolen(value_sv) : NULL;
    CFCParamList_add_param(self, variable, value);
#line 2133 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__ParamList__set_or_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__ParamList__set_or_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCParamList *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::ParamList")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCParamList *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::ParamList");
	};
#line 934 "lib/Clownfish/CFC.xs"
{
    START_SET_OR_GET_SWITCH
        case 2: {
                AV *av = newAV();
                CFCVariable **vars = CFCParamList_get_variables(self);
                size_t i;
                size_t num_vars = CFCParamList_num_vars(self);
                for (i = 0; i < num_vars; i++) {
                    SV *ref = S_cfcbase_to_perlref(vars[i]);
                    av_store(av, i, ref);
                }
                retval = newRV((SV*)av);
                SvREFCNT_dec(av);
                break;
            }
        case 4: {
                AV *av = newAV();
                const char **values = CFCParamList_get_initial_values(self);
                size_t i;
                size_t num_vars = CFCParamList_num_vars(self);
                for (i = 0; i < num_vars; i++) {
                    if (values[i] != NULL) {
                        SV *val_sv = newSVpvn(values[i], strlen(values[i]));
                        av_store(av, i, val_sv);
                    }
                    else {
                        av_store(av, i, newSV(0));
                    }
                }
                retval = newRV((SV*)av);
                SvREFCNT_dec(av);
                break;
            }
        case 6:
            retval = newSViv(CFCParamList_variadic(self));
            break;
        case 8:
            retval = newSViv(CFCParamList_num_vars(self));
            break;
        case 10: {
                const char *value = CFCParamList_to_c(self);
                retval = newSVpv(value, strlen(value));
            }
            break;
        case 12: {
                const char *value = CFCParamList_name_list(self);
                retval = newSVpv(value, strlen(value));
            }
            break;
    END_SET_OR_GET_SWITCH
}
#line 2218 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Parcel__singleton); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Parcel__singleton)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "name_sv, cnick_sv");
    {
	SV *	name_sv = ST(0);
	SV *	cnick_sv = ST(1);
	SV *	RETVAL;
#line 994 "lib/Clownfish/CFC.xs"
    const char *name  = SvOK(name_sv)  ? SvPV_nolen(name_sv)  : NULL;
    const char *cnick = SvOK(cnick_sv) ? SvPV_nolen(cnick_sv) : NULL;
    CFCParcel *self = CFCParcel_singleton(name, cnick);
    RETVAL = S_cfcbase_to_perlref(self);
#line 2244 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Parcel_equals); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Parcel_equals)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, other");
    {
	CFCParcel *	self;
	CFCParcel *	other;
	int	RETVAL;
	dXSTARG;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};

	if (!SvOK(ST(1))) {
        other = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};
#line 1005 "lib/Clownfish/CFC.xs"
    RETVAL = CFCParcel_equals(self, other);
#line 2291 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Parcel_default_parcel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Parcel_default_parcel)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	RETVAL;
#line 1011 "lib/Clownfish/CFC.xs"
    CFCParcel *default_parcel = CFCParcel_default_parcel();
    RETVAL = S_cfcbase_to_perlref(default_parcel);
#line 2312 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Parcel_reap_singletons); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Parcel_reap_singletons)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 1018 "lib/Clownfish/CFC.xs"
    CFCParcel_reap_singletons();
#line 2334 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Parcel__set_or_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Parcel__set_or_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCParcel *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};
#line 1030 "lib/Clownfish/CFC.xs"
{
    START_SET_OR_GET_SWITCH
        case 2: {
                const char *name = CFCParcel_get_name(self);
                retval = newSVpvn(name, strlen(name));
            }
            break;
        case 4: {
                const char *cnick = CFCParcel_get_cnick(self);
                retval = newSVpvn(cnick, strlen(cnick));
            }
            break;
        case 6: {
                const char *value = CFCParcel_get_prefix(self);
                retval = newSVpvn(value, strlen(value));
            }
            break;
        case 8: {
                const char *value = CFCParcel_get_Prefix(self);
                retval = newSVpvn(value, strlen(value));
            }
            break;
        case 10: {
                const char *value = CFCParcel_get_PREFIX(self);
                retval = newSVpvn(value, strlen(value));
            }
            break;
    END_SET_OR_GET_SWITCH
}
#line 2397 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Symbol__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Symbol__new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "parcel, exposure, class_name_sv, class_cnick_sv, micro_sym_sv");
    {
	CFCParcel *	parcel;
	const char *	exposure = (const char *)SvPV_nolen(ST(1));
	SV *	class_name_sv = ST(2);
	SV *	class_cnick_sv = ST(3);
	SV *	micro_sym_sv = ST(4);
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        parcel = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		parcel = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};
#line 1071 "lib/Clownfish/CFC.xs"
    const char *class_name  = SvOK(class_name_sv)
                              ? SvPV_nolen(class_name_sv)
                              : NULL;
    const char *class_cnick = SvOK(class_cnick_sv)
                              ? SvPV_nolen(class_cnick_sv)
                              : NULL;
    const char *micro_sym   = SvOK(micro_sym_sv)
                              ? SvPV_nolen(micro_sym_sv)
                              : NULL;
    CFCSymbol *self = CFCSymbol_new(parcel, exposure, class_name, class_cnick,
                                    micro_sym);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 2446 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Symbol_equals); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Symbol_equals)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, other");
    {
	CFCSymbol *	self;
	CFCSymbol *	other;
	int	RETVAL;
	dXSTARG;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Symbol")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCSymbol *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Symbol");
	};

	if (!SvOK(ST(1))) {
        other = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Symbol")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(CFCSymbol *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Symbol");
	};
#line 1091 "lib/Clownfish/CFC.xs"
    RETVAL = CFCSymbol_equals(self, other);
#line 2493 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Symbol__set_or_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Symbol__set_or_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCSymbol *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Symbol")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCSymbol *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Symbol");
	};
#line 1113 "lib/Clownfish/CFC.xs"
{
    START_SET_OR_GET_SWITCH
        case 2: {
                struct CFCParcel *parcel = CFCSymbol_get_parcel(self);
                retval = S_cfcbase_to_perlref(parcel);
            }
            break;
        case 4: {
                const char *class_name = CFCSymbol_get_class_name(self);
                retval = class_name
                         ? newSVpvn(class_name, strlen(class_name))
                         : newSV(0);
            }
            break;
        case 6: {
                const char *class_cnick = CFCSymbol_get_class_cnick(self);
                retval = class_cnick
                         ? newSVpvn(class_cnick, strlen(class_cnick))
                         : newSV(0);
            }
            break;
        case 8: {
                const char *exposure = CFCSymbol_get_exposure(self);
                retval = newSVpvn(exposure, strlen(exposure));
            }
            break;
        case 10: {
                const char *micro_sym = CFCSymbol_micro_sym(self);
                retval = newSVpvn(micro_sym, strlen(micro_sym));
            }
            break;
        case 12: {
                const char *value = CFCSymbol_get_prefix(self);
                retval = newSVpvn(value, strlen(value));
            }
            break;
        case 14: {
                const char *value = CFCSymbol_get_Prefix(self);
                retval = newSVpvn(value, strlen(value));
            }
            break;
        case 16: {
                const char *value = CFCSymbol_get_PREFIX(self);
                retval = newSVpvn(value, strlen(value));
            }
            break;
        case 18:
            retval = newSViv(CFCSymbol_public(self));
            break;
        case 20:
            retval = newSViv(CFCSymbol_private(self));
            break;
        case 22:
            retval = newSViv(CFCSymbol_parcel(self));
            break;
        case 24:
            retval = newSViv(CFCSymbol_local(self));
            break;
        case 26: {
                const char *short_sym = CFCSymbol_short_sym(self);
                retval = newSVpvn(short_sym, strlen(short_sym));
            }
            break;
        case 28: {
                const char *full_sym = CFCSymbol_full_sym(self);
                retval = newSVpvn(full_sym, strlen(full_sym));
            }
            break;
    END_SET_OR_GET_SWITCH
}
#line 2597 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Type__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type__new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "flags, parcel, specifier, indirection, c_string");
    {
	int	flags = (int)SvIV(ST(0));
	CFCParcel *	parcel;
	const char *	specifier = (const char *)SvPV_nolen(ST(2));
	int	indirection = (int)SvIV(ST(3));
	const char *	c_string = (const char *)SvPV_nolen(ST(4));
	SV *	RETVAL;

	if (!SvOK(ST(1))) {
        parcel = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		parcel = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};
#line 1195 "lib/Clownfish/CFC.xs"
    CFCType *self = CFCType_new(flags, parcel, specifier, indirection,
                                c_string);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 2637 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type__new_integer); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type__new_integer)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "flags, specifier");
    {
	int	flags = (int)SvIV(ST(0));
	const char *	specifier = (const char *)SvPV_nolen(ST(1));
	SV *	RETVAL;
#line 1206 "lib/Clownfish/CFC.xs"
    CFCType *self = CFCType_new_integer(flags, specifier);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 2663 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type__new_float); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type__new_float)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "flags, specifier");
    {
	int	flags = (int)SvIV(ST(0));
	const char *	specifier = (const char *)SvPV_nolen(ST(1));
	SV *	RETVAL;
#line 1216 "lib/Clownfish/CFC.xs"
    CFCType *self = CFCType_new_float(flags, specifier);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 2689 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type__new_object); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type__new_object)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "flags, parcel, specifier, indirection");
    {
	int	flags = (int)SvIV(ST(0));
	CFCParcel *	parcel;
	const char *	specifier = (const char *)SvPV_nolen(ST(2));
	int	indirection = (int)SvIV(ST(3));
	SV *	RETVAL;

	if (!SvOK(ST(1))) {
        parcel = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		parcel = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};
#line 1228 "lib/Clownfish/CFC.xs"
    CFCType *self = CFCType_new_object(flags, parcel, specifier, indirection);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 2728 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type__new_composite); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type__new_composite)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "flags, child_sv, indirection, array");
    {
	int	flags = (int)SvIV(ST(0));
	SV *	child_sv = ST(1);
	int	indirection = (int)SvIV(ST(2));
	const char *	array = (const char *)SvPV_nolen(ST(3));
	SV *	RETVAL;
#line 1240 "lib/Clownfish/CFC.xs"
    CFCType *child = NULL;
    if (SvOK(child_sv) && sv_derived_from(child_sv, "Clownfish::CFC::Type")) {
        IV objint = SvIV((SV*)SvRV(child_sv));
        child = INT2PTR(CFCType*, objint);
    }
    else {
        croak("Param 'child' not a Clownfish::CFC::Type");
    }
    CFCType *self = CFCType_new_composite(flags, child, indirection, array);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 2764 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type__new_void); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type__new_void)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "is_const");
    {
	int	is_const = (int)SvIV(ST(0));
	SV *	RETVAL;
#line 1257 "lib/Clownfish/CFC.xs"
    CFCType *self = CFCType_new_void(is_const);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 2789 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type__new_va_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type__new_va_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 1265 "lib/Clownfish/CFC.xs"
    CFCType *self = CFCType_new_va_list();
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 2813 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type__new_arbitrary); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type__new_arbitrary)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "parcel, specifier");
    {
	CFCParcel *	parcel;
	const char *	specifier = (const char *)SvPV_nolen(ST(1));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        parcel = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		parcel = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};
#line 1275 "lib/Clownfish/CFC.xs"
    CFCType *self = CFCType_new_arbitrary(parcel, specifier);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 2850 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_equals); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_equals)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, other");
    {
	CFCType *	self;
	CFCType *	other;
	int	RETVAL;
	dXSTARG;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Type")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCType *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Type");
	};

	if (!SvOK(ST(1))) {
        other = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Type")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(CFCType *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Type");
	};
#line 1285 "lib/Clownfish/CFC.xs"
    RETVAL = CFCType_equals(self, other);
#line 2897 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_similar); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_similar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, other");
    {
	CFCType *	self;
	CFCType *	other;
	int	RETVAL;
	dXSTARG;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Type")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCType *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Type");
	};

	if (!SvOK(ST(1))) {
        other = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Type")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(CFCType *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Type");
	};
#line 1293 "lib/Clownfish/CFC.xs"
    RETVAL = CFCType_similar(self, other);
#line 2943 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_CONST); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_CONST)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1299 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_CONST;
#line 2964 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_NULLABLE); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_NULLABLE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1305 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_NULLABLE;
#line 2985 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_INCREMENTED); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_INCREMENTED)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1311 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_INCREMENTED;
#line 3006 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_DECREMENTED); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_DECREMENTED)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1317 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_DECREMENTED;
#line 3027 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_VOID); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_VOID)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1323 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_VOID;
#line 3048 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_OBJECT); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_OBJECT)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1329 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_OBJECT;
#line 3069 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_PRIMITIVE); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_PRIMITIVE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1335 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_PRIMITIVE;
#line 3090 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_INTEGER); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_INTEGER)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1341 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_INTEGER;
#line 3111 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_FLOATING); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_FLOATING)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1347 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_FLOATING;
#line 3132 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_STRING_TYPE); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_STRING_TYPE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1353 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_STRING_TYPE;
#line 3153 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_VA_LIST); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_VA_LIST)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1359 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_VA_LIST;
#line 3174 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_ARBITRARY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_ARBITRARY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1365 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_ARBITRARY;
#line 3195 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type_COMPOSITE); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type_COMPOSITE)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	unsigned	RETVAL;
	dXSTARG;
#line 1371 "lib/Clownfish/CFC.xs"
    RETVAL = CFCTYPE_COMPOSITE;
#line 3216 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Type__set_or_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Type__set_or_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCType *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Type")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCType *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Type");
	};
#line 1401 "lib/Clownfish/CFC.xs"
{
    START_SET_OR_GET_SWITCH
        case 1:
            CFCType_set_specifier(self, SvPV_nolen(ST(1)));
            break;
        case 2: {
                const char *specifier = CFCType_get_specifier(self);
                retval = newSVpvn(specifier, strlen(specifier));
            }
            break;
        case 4: {
                CFCParcel *parcel = CFCType_get_parcel(self);
                retval = S_cfcbase_to_perlref(parcel);
            }
            break;
        case 6:
            retval = newSViv(CFCType_get_indirection(self));
            break;
        case 7:
            CFCType_set_c_string(self, SvPV_nolen(ST(1)));
        case 8: {
                const char *c_string = CFCType_to_c(self);
                retval = newSVpvn(c_string, strlen(c_string));
            }
            break;
        case 10:
            retval = newSViv(CFCType_const(self));
            break;
        case 11:
            CFCType_set_nullable(self, !!SvTRUE(ST(1)));
            break;
        case 12:
            retval = newSViv(CFCType_nullable(self));
            break;
        case 14:
            retval = newSViv(CFCType_is_void(self));
            break;
        case 16:
            retval = newSViv(CFCType_is_object(self));
            break;
        case 18:
            retval = newSViv(CFCType_is_primitive(self));
            break;
        case 20:
            retval = newSViv(CFCType_is_integer(self));
            break;
        case 22:
            retval = newSViv(CFCType_is_floating(self));
            break;
        case 24:
            retval = newSViv(CFCType_is_string_type(self));
            break;
        case 26:
            retval = newSViv(CFCType_is_va_list(self));
            break;
        case 28:
            retval = newSViv(CFCType_is_arbitrary(self));
            break;
        case 30:
            retval = newSViv(CFCType_is_composite(self));
            break;
        case 32:
            retval = newSVuv(CFCType_get_width(self));
            break;
        case 34:
            retval = newSVuv(CFCType_incremented(self));
            break;
        case 36:
            retval = newSVuv(CFCType_decremented(self));
            break;
        case 38: {
                const char *array = CFCType_get_array(self);
                retval = array
                         ? newSVpvn(array, strlen(array))
                         : newSV(0);
            }
            break;
    END_SET_OR_GET_SWITCH
}
#line 3329 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Util_trim_whitespace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Util_trim_whitespace)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "text");
    {
	SV *	text = ST(0);
	SV *	RETVAL;
#line 1488 "lib/Clownfish/CFC.xs"
    RETVAL = newSVsv(text);
    STRLEN len;
    char *ptr = SvPV(RETVAL, len);
    CFCUtil_trim_whitespace(ptr);
    SvCUR_set(RETVAL, strlen(ptr));
#line 3355 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Util_slurp_text); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Util_slurp_text)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	const char *	path = (const char *)SvPV_nolen(ST(0));
	SV *	RETVAL;
#line 1499 "lib/Clownfish/CFC.xs"
    size_t len;
    char *contents = CFCUtil_slurp_text(path, &len);
    RETVAL = newSVpvn(contents, len);
    FREEMEM(contents);
#line 3381 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Util_current); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Util_current)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "orig, dest");
    {
	const char *	orig = (const char *)SvPV_nolen(ST(0));
	const char *	dest = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;
#line 1510 "lib/Clownfish/CFC.xs"
    RETVAL = CFCUtil_current(orig, dest);
#line 3406 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Util_write_if_changed); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Util_write_if_changed)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "path, content_sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	const char *	path = (const char *)SvPV_nolen(ST(0));
	SV *	content_sv = ST(1);
#line 1518 "lib/Clownfish/CFC.xs"
    STRLEN len;
    char *content = SvPV(content_sv, len);
    CFCUtil_write_if_changed(path, content, len);
#line 3432 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Util_is_dir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Util_is_dir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	const char *	path = (const char *)SvPV_nolen(ST(0));
	int	RETVAL;
	dXSTARG;
#line 1526 "lib/Clownfish/CFC.xs"
    RETVAL = CFCUtil_is_dir(path);
#line 3455 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Util_make_dir); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Util_make_dir)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "dir");
    {
	const char *	dir = (const char *)SvPV_nolen(ST(0));
	int	RETVAL;
	dXSTARG;
#line 1533 "lib/Clownfish/CFC.xs"
    RETVAL = CFCUtil_make_dir(dir);
#line 3478 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Util_make_path); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Util_make_path)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	const char *	path = (const char *)SvPV_nolen(ST(0));
	int	RETVAL;
	dXSTARG;
#line 1540 "lib/Clownfish/CFC.xs"
    RETVAL = CFCUtil_make_path(path);
#line 3501 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Variable__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Variable__new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 7)
       croak_xs_usage(cv,  "parcel, exposure, class_name_sv, class_cnick_sv, micro_sym_sv, type_sv, inert_sv");
    {
	CFCParcel *	parcel;
	const char *	exposure = (const char *)SvPV_nolen(ST(1));
	SV *	class_name_sv = ST(2);
	SV *	class_cnick_sv = ST(3);
	SV *	micro_sym_sv = ST(4);
	SV *	type_sv = ST(5);
	SV *	inert_sv = ST(6);
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        parcel = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		parcel = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};
#line 1555 "lib/Clownfish/CFC.xs"
    const char *class_name  = SvOK(class_name_sv)
                              ? SvPV_nolen(class_name_sv)
                              : NULL;
    const char *class_cnick = SvOK(class_cnick_sv)
                              ? SvPV_nolen(class_cnick_sv)
                              : NULL;
    const char *micro_sym   = SvOK(micro_sym_sv)
                              ? SvPV_nolen(micro_sym_sv)
                              : NULL;
    int inert               = SvOK(inert_sv)
                              ? !!SvTRUE(inert_sv) : 0;
    CFCType *type = NULL;
    if (SvOK(type_sv) && sv_derived_from(type_sv, "Clownfish::CFC::Type")) {
        IV objint = SvIV((SV*)SvRV(type_sv));
        type = INT2PTR(CFCType*, objint);
    }
    else {
        croak("Param 'type' is not a Clownfish::CFC::Type");
    }
    CFCVariable *self = CFCVariable_new(parcel, exposure, class_name,
                                        class_cnick, micro_sym, type, inert);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 3562 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Variable_equals); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Variable_equals)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, other");
    {
	CFCVariable *	self;
	CFCVariable *	other;
	int	RETVAL;
	dXSTARG;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Variable")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCVariable *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Variable");
	};

	if (!SvOK(ST(1))) {
        other = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Variable")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		other = INT2PTR(CFCVariable *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Variable");
	};
#line 1585 "lib/Clownfish/CFC.xs"
    RETVAL = CFCVariable_equals(self, other);
#line 3609 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Variable__set_or_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Variable__set_or_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCVariable *	self;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Variable")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCVariable *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Variable");
	};
#line 1597 "lib/Clownfish/CFC.xs"
{
    START_SET_OR_GET_SWITCH
        case 2: {
                CFCType *type = CFCVariable_get_type(self);
                retval = S_cfcbase_to_perlref(type);
            }
            break;
        case 4: {
                const char *local_c = CFCVariable_local_c(self);
                retval = newSVpvn(local_c, strlen(local_c));
            }
            break;
        case 6: {
                const char *global_c = CFCVariable_global_c(self);
                retval = newSVpvn(global_c, strlen(global_c));
            }
            break;
        case 8: {
                const char *local_dec = CFCVariable_local_declaration(self);
                retval = newSVpvn(local_dec, strlen(local_dec));
            }
            break;
    END_SET_OR_GET_SWITCH
}
#line 3667 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Binding__Core__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "hierarchy, dest, header, footer");
    {
	CFCHierarchy *	hierarchy;
	const char *	dest = (const char *)SvPV_nolen(ST(1));
	const char *	header = (const char *)SvPV_nolen(ST(2));
	const char *	footer = (const char *)SvPV_nolen(ST(3));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        hierarchy = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Hierarchy")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		hierarchy = INT2PTR(CFCHierarchy *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Hierarchy");
	};
#line 1631 "lib/Clownfish/CFC.xs"
    CFCBindCore *self = CFCBindCore_new(hierarchy, dest, header, footer);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 3705 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core_write_all_modified); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core_write_all_modified)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "self, ...");
    {
	CFCBindCore *	self;
	int	RETVAL;
	dXSTARG;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Binding::Core")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCBindCore *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Binding::Core");
	};
#line 1640 "lib/Clownfish/CFC.xs"
{
    int modified = 0;
    if (items > 1 && SvOK(ST(1))) {
        modified = !!SvIV(ST(1));
    }
    RETVAL = CFCBindCore_write_all_modified(self, modified);
}
#line 3746 "lib/Clownfish/CFC.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core__Function_func_declaration); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__Function_func_declaration)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "unused, func");
    {
	SV *	unused = ST(0);
	CFCFunction *	func;
	SV *	RETVAL;

	if (!SvOK(ST(1))) {
        func = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Function")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		func = INT2PTR(CFCFunction *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Function");
	};
#line 1657 "lib/Clownfish/CFC.xs"
    RETVAL = S_sv_eat_c_string(CFCBindFunc_func_declaration(func));
#line 3780 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core__Method_typedef_dec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__Method_typedef_dec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "unused, meth");
    {
	SV *	unused = ST(0);
	CFCMethod *	meth;
	SV *	RETVAL;

	if (!SvOK(ST(1))) {
        meth = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		meth = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};
#line 1667 "lib/Clownfish/CFC.xs"
    RETVAL = S_sv_eat_c_string(CFCBindMeth_typdef_dec(meth));
#line 3815 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core__Method_abstract_method_def); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__Method_abstract_method_def)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "unused, meth");
    {
	SV *	unused = ST(0);
	CFCMethod *	meth;
	SV *	RETVAL;

	if (!SvOK(ST(1))) {
        meth = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		meth = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};
#line 1675 "lib/Clownfish/CFC.xs"
    RETVAL = S_sv_eat_c_string(CFCBindMeth_abstract_method_def(meth));
#line 3850 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core__Method_callback_dec); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__Method_callback_dec)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "unused, meth");
    {
	SV *	unused = ST(0);
	CFCMethod *	meth;
	SV *	RETVAL;

	if (!SvOK(ST(1))) {
        meth = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		meth = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};
#line 1683 "lib/Clownfish/CFC.xs"
    RETVAL = S_sv_eat_c_string(CFCBindMeth_callback_dec(meth));
#line 3885 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core__Method_callback_def); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__Method_callback_def)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "unused, meth");
    {
	SV *	unused = ST(0);
	CFCMethod *	meth;
	SV *	RETVAL;

	if (!SvOK(ST(1))) {
        meth = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		meth = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};
#line 1691 "lib/Clownfish/CFC.xs"
    RETVAL = S_sv_eat_c_string(CFCBindMeth_callback_def(meth));
#line 3920 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core__Method__method_def); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__Method__method_def)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "meth, klass");
    {
	CFCMethod *	meth;
	CFCClass *	klass;
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        meth = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		meth = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};

	if (!SvOK(ST(1))) {
        klass = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		klass = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};
#line 1699 "lib/Clownfish/CFC.xs"
    RETVAL = S_sv_eat_c_string(CFCBindMeth_method_def(meth, klass));
#line 3966 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core__Method__callback_obj_def); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__Method__callback_obj_def)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "meth, offset");
    {
	CFCMethod *	meth;
	const char *	offset = (const char *)SvPV_nolen(ST(1));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        meth = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Method")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		meth = INT2PTR(CFCMethod *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Method");
	};
#line 1707 "lib/Clownfish/CFC.xs"
    RETVAL = S_sv_eat_c_string(CFCBindMeth_callback_obj_def(meth, offset));
#line 4001 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core__Aliases_c_aliases); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__Aliases_c_aliases)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    PERL_UNUSED_VAR(cv); /* -W */
    {
	SV *	RETVAL;
#line 1715 "lib/Clownfish/CFC.xs"
    RETVAL = S_sv_eat_c_string(CFCBindAliases_c_aliases());
#line 4022 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core__Class__new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__Class__new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "client");
    {
	CFCClass *	client;
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        client = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		client = INT2PTR(CFCClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Class");
	};
#line 1724 "lib/Clownfish/CFC.xs"
    CFCBindClass *self = CFCBindClass_new(client);
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 4058 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core__Class_to_c); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__Class_to_c)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	CFCBindClass *	self;
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Binding::Core::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCBindClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Binding::Core::Class");
	};
#line 1733 "lib/Clownfish/CFC.xs"
    RETVAL = S_sv_eat_c_string(CFCBindClass_to_c(self));
#line 4092 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core__Class_to_c_header); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__Class_to_c_header)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	CFCBindClass *	self;
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Binding::Core::Class")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCBindClass *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Binding::Core::Class");
	};
#line 1740 "lib/Clownfish/CFC.xs"
    RETVAL = S_sv_eat_c_string(CFCBindClass_to_c_header(self));
#line 4126 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Binding__Core__File__write_h); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Binding__Core__File__write_h)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "file, dest, header, footer");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCFile *	file;
	const char *	dest = (const char *)SvPV_nolen(ST(1));
	const char *	header = (const char *)SvPV_nolen(ST(2));
	const char *	footer = (const char *)SvPV_nolen(ST(3));

	if (!SvOK(ST(0))) {
        file = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::File")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		file = INT2PTR(CFCFile *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::File");
	};
#line 1752 "lib/Clownfish/CFC.xs"
    CFCBindFile_write_h(file, dest, header, footer);
#line 4164 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Parser_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Parser_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "klass");
    {
	const char *	klass = (const char *)SvPV_nolen(ST(0));
	SV *	RETVAL;
#line 1761 "lib/Clownfish/CFC.xs"
    if (strcmp(klass, "Clownfish::CFC::Parser")) {
        croak("No subclassing allowed");
    }
    CFCParser *self = CFCParser_new();
    RETVAL = S_cfcbase_to_perlref(self);
    CFCBase_decref((CFCBase*)self);
#line 4191 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Parser_parse); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Parser_parse)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, string");
    {
	CFCParser *	self;
	const char *	string = (const char *)SvPV_nolen(ST(1));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parser")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCParser *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parser");
	};
#line 1774 "lib/Clownfish/CFC.xs"
    CFCBase *got = CFCParser_parse(self, string);
    RETVAL = S_cfcbase_to_perlref(got);
    CFCBase_decref((CFCBase*)got);
#line 4228 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Parser__parse_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Parser__parse_file)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "self, string, source_class");
    {
	CFCParser *	self;
	const char *	string = (const char *)SvPV_nolen(ST(1));
	const char *	source_class = (const char *)SvPV_nolen(ST(2));
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parser")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCParser *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parser");
	};
#line 1785 "lib/Clownfish/CFC.xs"
    CFCFile *got = CFCParser_parse_file(self, string, source_class);
    RETVAL = S_cfcbase_to_perlref(got);
    CFCBase_decref((CFCBase*)got);
#line 4266 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Clownfish__CFC__Parser_set_parcel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Parser_set_parcel)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, parcel");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCParser *	self;
	CFCParcel *	parcel;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parser")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCParser *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parser");
	};

	if (!SvOK(ST(1))) {
        parcel = NULL;
    }
	else if (sv_derived_from(ST(1), "Clownfish::CFC::Parcel")) {
		IV objint = SvIV((SV*)SvRV(ST(1)));
		parcel = INT2PTR(CFCParcel *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parcel");
	};
#line 1795 "lib/Clownfish/CFC.xs"
    CFCParser_set_parcel(self, parcel);
#line 4313 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Parser_set_class_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Parser_set_class_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, class_name");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCParser *	self;
	const char *	class_name = (const char *)SvPV_nolen(ST(1));

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parser")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCParser *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parser");
	};
#line 1802 "lib/Clownfish/CFC.xs"
    CFCParser_set_class_name(self, class_name);
#line 4348 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Parser_set_class_cnick); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Parser_set_class_cnick)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, class_cnick");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	CFCParser *	self;
	const char *	class_cnick = (const char *)SvPV_nolen(ST(1));

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parser")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCParser *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parser");
	};
#line 1809 "lib/Clownfish/CFC.xs"
    CFCParser_set_class_cnick(self, class_cnick);
#line 4383 "lib/Clownfish/CFC.c"
	PUTBACK;
	return;
    }
}


XS(XS_Clownfish__CFC__Parser_get_parcel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Clownfish__CFC__Parser_get_parcel)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	CFCParser *	self;
	SV *	RETVAL;

	if (!SvOK(ST(0))) {
        self = NULL;
    }
	else if (sv_derived_from(ST(0), "Clownfish::CFC::Parser")) {
		IV objint = SvIV((SV*)SvRV(ST(0)));
		self = INT2PTR(CFCParser *, objint);
	}
    else {
		croak("Not a Clownfish::CFC::Parser");
	};
#line 1815 "lib/Clownfish/CFC.xs"
    CFCParcel *parcel = CFCParser_get_parcel(self);
    RETVAL = S_cfcbase_to_perlref((CFCBase*)parcel);
#line 4417 "lib/Clownfish/CFC.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Clownfish__CFC); /* prototype to pass -Wmissing-prototypes */
XS(boot_Clownfish__CFC)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

        newXS("Clownfish::CFC::Base::DESTROY", XS_Clownfish__CFC__Base_DESTROY, file);
        newXS("Clownfish::CFC::CBlock::_new", XS_Clownfish__CFC__CBlock__new, file);
        cv = newXS("Clownfish::CFC::CBlock::_set_or_get", XS_Clownfish__CFC__CBlock__set_or_get, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::CBlock::get_contents", XS_Clownfish__CFC__CBlock__set_or_get, file);
        XSANY.any_i32 = 2 ;
        newXS("Clownfish::CFC::Class::_create", XS_Clownfish__CFC__Class__create, file);
        newXS("Clownfish::CFC::Class::_fetch_singleton", XS_Clownfish__CFC__Class__fetch_singleton, file);
        newXS("Clownfish::CFC::Class::_clear_registry", XS_Clownfish__CFC__Class__clear_registry, file);
        newXS("Clownfish::CFC::Class::append_autocode", XS_Clownfish__CFC__Class_append_autocode, file);
        newXS("Clownfish::CFC::Class::add_child", XS_Clownfish__CFC__Class_add_child, file);
        newXS("Clownfish::CFC::Class::add_member_var", XS_Clownfish__CFC__Class_add_member_var, file);
        newXS("Clownfish::CFC::Class::add_function", XS_Clownfish__CFC__Class_add_function, file);
        newXS("Clownfish::CFC::Class::add_method", XS_Clownfish__CFC__Class_add_method, file);
        newXS("Clownfish::CFC::Class::add_attribute", XS_Clownfish__CFC__Class_add_attribute, file);
        newXS("Clownfish::CFC::Class::has_attribute", XS_Clownfish__CFC__Class_has_attribute, file);
        newXS("Clownfish::CFC::Class::grow_tree", XS_Clownfish__CFC__Class_grow_tree, file);
        newXS("Clownfish::CFC::Class::add_inert_var", XS_Clownfish__CFC__Class_add_inert_var, file);
        newXS("Clownfish::CFC::Class::function", XS_Clownfish__CFC__Class_function, file);
        newXS("Clownfish::CFC::Class::method", XS_Clownfish__CFC__Class_method, file);
        newXS("Clownfish::CFC::Class::novel_method", XS_Clownfish__CFC__Class_novel_method, file);
        cv = newXS("Clownfish::CFC::Class::full_vtable_type", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 26 ;
        cv = newXS("Clownfish::CFC::Class::methods", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 36 ;
        cv = newXS("Clownfish::CFC::Class::final", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 14 ;
        cv = newXS("Clownfish::CFC::Class::novel_methods", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 44 ;
        cv = newXS("Clownfish::CFC::Class::set_parent", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 5 ;
        cv = newXS("Clownfish::CFC::Class::short_vtable_var", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 22 ;
        cv = newXS("Clownfish::CFC::Class::tree_to_ladder", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 42 ;
        cv = newXS("Clownfish::CFC::Class::inert_vars", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 40 ;
        cv = newXS("Clownfish::CFC::Class::full_struct_sym", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 20 ;
        cv = newXS("Clownfish::CFC::Class::get_cnick", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Clownfish::CFC::Class::get_autocode", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 8 ;
        cv = newXS("Clownfish::CFC::Class::privacy_symbol", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 48 ;
        cv = newXS("Clownfish::CFC::Class::full_vtable_var", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 24 ;
        cv = newXS("Clownfish::CFC::Class::get_docucomment", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 30 ;
        cv = newXS("Clownfish::CFC::Class::_set_or_get", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::Class::member_vars", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 38 ;
        cv = newXS("Clownfish::CFC::Class::get_source_class", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 10 ;
        cv = newXS("Clownfish::CFC::Class::functions", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 34 ;
        cv = newXS("Clownfish::CFC::Class::get_struct_sym", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 18 ;
        cv = newXS("Clownfish::CFC::Class::children", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 32 ;
        cv = newXS("Clownfish::CFC::Class::get_parent", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 6 ;
        cv = newXS("Clownfish::CFC::Class::include_h", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 28 ;
        cv = newXS("Clownfish::CFC::Class::novel_member_vars", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 46 ;
        cv = newXS("Clownfish::CFC::Class::inert", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 16 ;
        cv = newXS("Clownfish::CFC::Class::get_parent_class_name", XS_Clownfish__CFC__Class__set_or_get, file);
        XSANY.any_i32 = 12 ;
        newXS("Clownfish::CFC::DocuComment::parse", XS_Clownfish__CFC__DocuComment_parse, file);
        cv = newXS("Clownfish::CFC::DocuComment::get_description", XS_Clownfish__CFC__DocuComment__set_or_get, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Clownfish::CFC::DocuComment::get_long", XS_Clownfish__CFC__DocuComment__set_or_get, file);
        XSANY.any_i32 = 6 ;
        cv = newXS("Clownfish::CFC::DocuComment::_set_or_get", XS_Clownfish__CFC__DocuComment__set_or_get, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::DocuComment::get_brief", XS_Clownfish__CFC__DocuComment__set_or_get, file);
        XSANY.any_i32 = 4 ;
        cv = newXS("Clownfish::CFC::DocuComment::get_retval", XS_Clownfish__CFC__DocuComment__set_or_get, file);
        XSANY.any_i32 = 12 ;
        cv = newXS("Clownfish::CFC::DocuComment::get_param_docs", XS_Clownfish__CFC__DocuComment__set_or_get, file);
        XSANY.any_i32 = 10 ;
        cv = newXS("Clownfish::CFC::DocuComment::get_param_names", XS_Clownfish__CFC__DocuComment__set_or_get, file);
        XSANY.any_i32 = 8 ;
        newXS("Clownfish::CFC::Dumpable::new", XS_Clownfish__CFC__Dumpable_new, file);
        newXS("Clownfish::CFC::Dumpable::add_dumpables", XS_Clownfish__CFC__Dumpable_add_dumpables, file);
        newXS("Clownfish::CFC::File::_new", XS_Clownfish__CFC__File__new, file);
        newXS("Clownfish::CFC::File::add_block", XS_Clownfish__CFC__File_add_block, file);
        cv = newXS("Clownfish::CFC::File::guard_close", XS_Clownfish__CFC__File__set_or_get, file);
        XSANY.any_i32 = 10 ;
        cv = newXS("Clownfish::CFC::File::blocks", XS_Clownfish__CFC__File__set_or_get, file);
        XSANY.any_i32 = 12 ;
        cv = newXS("Clownfish::CFC::File::get_source_class", XS_Clownfish__CFC__File__set_or_get, file);
        XSANY.any_i32 = 4 ;
        cv = newXS("Clownfish::CFC::File::guard_start", XS_Clownfish__CFC__File__set_or_get, file);
        XSANY.any_i32 = 8 ;
        cv = newXS("Clownfish::CFC::File::get_modified", XS_Clownfish__CFC__File__set_or_get, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Clownfish::CFC::File::guard_name", XS_Clownfish__CFC__File__set_or_get, file);
        XSANY.any_i32 = 6 ;
        cv = newXS("Clownfish::CFC::File::_set_or_get", XS_Clownfish__CFC__File__set_or_get, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::File::classes", XS_Clownfish__CFC__File__set_or_get, file);
        XSANY.any_i32 = 14 ;
        cv = newXS("Clownfish::CFC::File::set_modified", XS_Clownfish__CFC__File__set_or_get, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Clownfish::CFC::File::_gen_path", XS_Clownfish__CFC__File__gen_path, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::File::c_path", XS_Clownfish__CFC__File__gen_path, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Clownfish::CFC::File::h_path", XS_Clownfish__CFC__File__gen_path, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Clownfish::CFC::File::cfh_path", XS_Clownfish__CFC__File__gen_path, file);
        XSANY.any_i32 = 3 ;
        newXS("Clownfish::CFC::Function::_new", XS_Clownfish__CFC__Function__new, file);
        cv = newXS("Clownfish::CFC::Function::full_func_sym", XS_Clownfish__CFC__Function__set_or_get, file);
        XSANY.any_i32 = 12 ;
        cv = newXS("Clownfish::CFC::Function::void", XS_Clownfish__CFC__Function__set_or_get, file);
        XSANY.any_i32 = 10 ;
        cv = newXS("Clownfish::CFC::Function::_set_or_get", XS_Clownfish__CFC__Function__set_or_get, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::Function::get_return_type", XS_Clownfish__CFC__Function__set_or_get, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Clownfish::CFC::Function::inline", XS_Clownfish__CFC__Function__set_or_get, file);
        XSANY.any_i32 = 8 ;
        cv = newXS("Clownfish::CFC::Function::get_param_list", XS_Clownfish__CFC__Function__set_or_get, file);
        XSANY.any_i32 = 4 ;
        cv = newXS("Clownfish::CFC::Function::get_docucomment", XS_Clownfish__CFC__Function__set_or_get, file);
        XSANY.any_i32 = 6 ;
        cv = newXS("Clownfish::CFC::Function::short_func_sym", XS_Clownfish__CFC__Function__set_or_get, file);
        XSANY.any_i32 = 14 ;
        newXS("Clownfish::CFC::Hierarchy::_new", XS_Clownfish__CFC__Hierarchy__new, file);
        newXS("Clownfish::CFC::Hierarchy::build", XS_Clownfish__CFC__Hierarchy_build, file);
        newXS("Clownfish::CFC::Hierarchy::propagate_modified", XS_Clownfish__CFC__Hierarchy_propagate_modified, file);
        cv = newXS("Clownfish::CFC::Hierarchy::_set_or_get", XS_Clownfish__CFC__Hierarchy__set_or_get, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::Hierarchy::files", XS_Clownfish__CFC__Hierarchy__set_or_get, file);
        XSANY.any_i32 = 8 ;
        cv = newXS("Clownfish::CFC::Hierarchy::get_source", XS_Clownfish__CFC__Hierarchy__set_or_get, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Clownfish::CFC::Hierarchy::ordered_classes", XS_Clownfish__CFC__Hierarchy__set_or_get, file);
        XSANY.any_i32 = 10 ;
        cv = newXS("Clownfish::CFC::Hierarchy::get_dest", XS_Clownfish__CFC__Hierarchy__set_or_get, file);
        XSANY.any_i32 = 4 ;
        newXS("Clownfish::CFC::Method::_new", XS_Clownfish__CFC__Method__new, file);
        newXS("Clownfish::CFC::Method::compatible", XS_Clownfish__CFC__Method_compatible, file);
        newXS("Clownfish::CFC::Method::override", XS_Clownfish__CFC__Method_override, file);
        newXS("Clownfish::CFC::Method::finalize", XS_Clownfish__CFC__Method_finalize, file);
        cv = newXS("Clownfish::CFC::Method::full_method_sym", XS_Clownfish__CFC__Method__various_method_syms, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Clownfish::CFC::Method::short_method_sym", XS_Clownfish__CFC__Method__various_method_syms, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Clownfish::CFC::Method::full_offset_sym", XS_Clownfish__CFC__Method__various_method_syms, file);
        XSANY.any_i32 = 3 ;
        cv = newXS("Clownfish::CFC::Method::_various_method_syms", XS_Clownfish__CFC__Method__various_method_syms, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::Method::full_callback_sym", XS_Clownfish__CFC__Method__set_or_get, file);
        XSANY.any_i32 = 8 ;
        cv = newXS("Clownfish::CFC::Method::abstract", XS_Clownfish__CFC__Method__set_or_get, file);
        XSANY.any_i32 = 12 ;
        cv = newXS("Clownfish::CFC::Method::self_type", XS_Clownfish__CFC__Method__set_or_get, file);
        XSANY.any_i32 = 18 ;
        cv = newXS("Clownfish::CFC::Method::full_override_sym", XS_Clownfish__CFC__Method__set_or_get, file);
        XSANY.any_i32 = 10 ;
        cv = newXS("Clownfish::CFC::Method::get_macro_sym", XS_Clownfish__CFC__Method__set_or_get, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Clownfish::CFC::Method::novel", XS_Clownfish__CFC__Method__set_or_get, file);
        XSANY.any_i32 = 14 ;
        cv = newXS("Clownfish::CFC::Method::_set_or_get", XS_Clownfish__CFC__Method__set_or_get, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::Method::final", XS_Clownfish__CFC__Method__set_or_get, file);
        XSANY.any_i32 = 16 ;
        cv = newXS("Clownfish::CFC::Method::full_typedef", XS_Clownfish__CFC__Method__set_or_get, file);
        XSANY.any_i32 = 6 ;
        cv = newXS("Clownfish::CFC::Method::short_typedef", XS_Clownfish__CFC__Method__set_or_get, file);
        XSANY.any_i32 = 4 ;
        newXS("Clownfish::CFC::ParamList::_new", XS_Clownfish__CFC__ParamList__new, file);
        newXS("Clownfish::CFC::ParamList::add_param", XS_Clownfish__CFC__ParamList_add_param, file);
        cv = newXS("Clownfish::CFC::ParamList::num_vars", XS_Clownfish__CFC__ParamList__set_or_get, file);
        XSANY.any_i32 = 8 ;
        cv = newXS("Clownfish::CFC::ParamList::_set_or_get", XS_Clownfish__CFC__ParamList__set_or_get, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::ParamList::name_list", XS_Clownfish__CFC__ParamList__set_or_get, file);
        XSANY.any_i32 = 12 ;
        cv = newXS("Clownfish::CFC::ParamList::variadic", XS_Clownfish__CFC__ParamList__set_or_get, file);
        XSANY.any_i32 = 6 ;
        cv = newXS("Clownfish::CFC::ParamList::get_initial_values", XS_Clownfish__CFC__ParamList__set_or_get, file);
        XSANY.any_i32 = 4 ;
        cv = newXS("Clownfish::CFC::ParamList::get_variables", XS_Clownfish__CFC__ParamList__set_or_get, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Clownfish::CFC::ParamList::to_c", XS_Clownfish__CFC__ParamList__set_or_get, file);
        XSANY.any_i32 = 10 ;
        newXS("Clownfish::CFC::Parcel::_singleton", XS_Clownfish__CFC__Parcel__singleton, file);
        newXS("Clownfish::CFC::Parcel::equals", XS_Clownfish__CFC__Parcel_equals, file);
        newXS("Clownfish::CFC::Parcel::default_parcel", XS_Clownfish__CFC__Parcel_default_parcel, file);
        newXS("Clownfish::CFC::Parcel::reap_singletons", XS_Clownfish__CFC__Parcel_reap_singletons, file);
        cv = newXS("Clownfish::CFC::Parcel::get_cnick", XS_Clownfish__CFC__Parcel__set_or_get, file);
        XSANY.any_i32 = 4 ;
        cv = newXS("Clownfish::CFC::Parcel::_set_or_get", XS_Clownfish__CFC__Parcel__set_or_get, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::Parcel::get_PREFIX", XS_Clownfish__CFC__Parcel__set_or_get, file);
        XSANY.any_i32 = 10 ;
        cv = newXS("Clownfish::CFC::Parcel::get_prefix", XS_Clownfish__CFC__Parcel__set_or_get, file);
        XSANY.any_i32 = 6 ;
        cv = newXS("Clownfish::CFC::Parcel::get_Prefix", XS_Clownfish__CFC__Parcel__set_or_get, file);
        XSANY.any_i32 = 8 ;
        cv = newXS("Clownfish::CFC::Parcel::get_name", XS_Clownfish__CFC__Parcel__set_or_get, file);
        XSANY.any_i32 = 2 ;
        newXS("Clownfish::CFC::Symbol::_new", XS_Clownfish__CFC__Symbol__new, file);
        newXS("Clownfish::CFC::Symbol::equals", XS_Clownfish__CFC__Symbol_equals, file);
        cv = newXS("Clownfish::CFC::Symbol::get_Prefix", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 14 ;
        cv = newXS("Clownfish::CFC::Symbol::micro_sym", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 10 ;
        cv = newXS("Clownfish::CFC::Symbol::get_parcel", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Clownfish::CFC::Symbol::get_class_name", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 4 ;
        cv = newXS("Clownfish::CFC::Symbol::get_exposure", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 8 ;
        cv = newXS("Clownfish::CFC::Symbol::get_PREFIX", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 16 ;
        cv = newXS("Clownfish::CFC::Symbol::get_class_cnick", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 6 ;
        cv = newXS("Clownfish::CFC::Symbol::full_sym", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 28 ;
        cv = newXS("Clownfish::CFC::Symbol::short_sym", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 26 ;
        cv = newXS("Clownfish::CFC::Symbol::_set_or_get", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::Symbol::parcel", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 22 ;
        cv = newXS("Clownfish::CFC::Symbol::public", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 18 ;
        cv = newXS("Clownfish::CFC::Symbol::get_prefix", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 12 ;
        cv = newXS("Clownfish::CFC::Symbol::local", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 24 ;
        cv = newXS("Clownfish::CFC::Symbol::private", XS_Clownfish__CFC__Symbol__set_or_get, file);
        XSANY.any_i32 = 20 ;
        newXS("Clownfish::CFC::Type::_new", XS_Clownfish__CFC__Type__new, file);
        newXS("Clownfish::CFC::Type::_new_integer", XS_Clownfish__CFC__Type__new_integer, file);
        newXS("Clownfish::CFC::Type::_new_float", XS_Clownfish__CFC__Type__new_float, file);
        newXS("Clownfish::CFC::Type::_new_object", XS_Clownfish__CFC__Type__new_object, file);
        newXS("Clownfish::CFC::Type::_new_composite", XS_Clownfish__CFC__Type__new_composite, file);
        newXS("Clownfish::CFC::Type::_new_void", XS_Clownfish__CFC__Type__new_void, file);
        newXS("Clownfish::CFC::Type::_new_va_list", XS_Clownfish__CFC__Type__new_va_list, file);
        newXS("Clownfish::CFC::Type::_new_arbitrary", XS_Clownfish__CFC__Type__new_arbitrary, file);
        newXS("Clownfish::CFC::Type::equals", XS_Clownfish__CFC__Type_equals, file);
        newXS("Clownfish::CFC::Type::similar", XS_Clownfish__CFC__Type_similar, file);
        newXS("Clownfish::CFC::Type::CONST", XS_Clownfish__CFC__Type_CONST, file);
        newXS("Clownfish::CFC::Type::NULLABLE", XS_Clownfish__CFC__Type_NULLABLE, file);
        newXS("Clownfish::CFC::Type::INCREMENTED", XS_Clownfish__CFC__Type_INCREMENTED, file);
        newXS("Clownfish::CFC::Type::DECREMENTED", XS_Clownfish__CFC__Type_DECREMENTED, file);
        newXS("Clownfish::CFC::Type::VOID", XS_Clownfish__CFC__Type_VOID, file);
        newXS("Clownfish::CFC::Type::OBJECT", XS_Clownfish__CFC__Type_OBJECT, file);
        newXS("Clownfish::CFC::Type::PRIMITIVE", XS_Clownfish__CFC__Type_PRIMITIVE, file);
        newXS("Clownfish::CFC::Type::INTEGER", XS_Clownfish__CFC__Type_INTEGER, file);
        newXS("Clownfish::CFC::Type::FLOATING", XS_Clownfish__CFC__Type_FLOATING, file);
        newXS("Clownfish::CFC::Type::STRING_TYPE", XS_Clownfish__CFC__Type_STRING_TYPE, file);
        newXS("Clownfish::CFC::Type::VA_LIST", XS_Clownfish__CFC__Type_VA_LIST, file);
        newXS("Clownfish::CFC::Type::ARBITRARY", XS_Clownfish__CFC__Type_ARBITRARY, file);
        newXS("Clownfish::CFC::Type::COMPOSITE", XS_Clownfish__CFC__Type_COMPOSITE, file);
        cv = newXS("Clownfish::CFC::Type::is_arbitrary", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 28 ;
        cv = newXS("Clownfish::CFC::Type::is_floating", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 22 ;
        cv = newXS("Clownfish::CFC::Type::is_string_type", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 24 ;
        cv = newXS("Clownfish::CFC::Type::nullable", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 12 ;
        cv = newXS("Clownfish::CFC::Type::get_indirection", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 6 ;
        cv = newXS("Clownfish::CFC::Type::set_specifier", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Clownfish::CFC::Type::get_parcel", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 4 ;
        cv = newXS("Clownfish::CFC::Type::is_va_list", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 26 ;
        cv = newXS("Clownfish::CFC::Type::is_void", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 14 ;
        cv = newXS("Clownfish::CFC::Type::get_array", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 38 ;
        cv = newXS("Clownfish::CFC::Type::get_width", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 32 ;
        cv = newXS("Clownfish::CFC::Type::is_object", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 16 ;
        cv = newXS("Clownfish::CFC::Type::_set_or_get", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::Type::decremented", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 36 ;
        cv = newXS("Clownfish::CFC::Type::is_integer", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 20 ;
        cv = newXS("Clownfish::CFC::Type::const", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 10 ;
        cv = newXS("Clownfish::CFC::Type::incremented", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 34 ;
        cv = newXS("Clownfish::CFC::Type::to_c", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 8 ;
        cv = newXS("Clownfish::CFC::Type::set_c_string", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 7 ;
        cv = newXS("Clownfish::CFC::Type::set_nullable", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 11 ;
        cv = newXS("Clownfish::CFC::Type::is_composite", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 30 ;
        cv = newXS("Clownfish::CFC::Type::get_specifier", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Clownfish::CFC::Type::is_primitive", XS_Clownfish__CFC__Type__set_or_get, file);
        XSANY.any_i32 = 18 ;
        newXS("Clownfish::CFC::Util::trim_whitespace", XS_Clownfish__CFC__Util_trim_whitespace, file);
        newXS("Clownfish::CFC::Util::slurp_text", XS_Clownfish__CFC__Util_slurp_text, file);
        newXS("Clownfish::CFC::Util::current", XS_Clownfish__CFC__Util_current, file);
        newXS("Clownfish::CFC::Util::write_if_changed", XS_Clownfish__CFC__Util_write_if_changed, file);
        newXS("Clownfish::CFC::Util::is_dir", XS_Clownfish__CFC__Util_is_dir, file);
        newXS("Clownfish::CFC::Util::make_dir", XS_Clownfish__CFC__Util_make_dir, file);
        newXS("Clownfish::CFC::Util::make_path", XS_Clownfish__CFC__Util_make_path, file);
        newXS("Clownfish::CFC::Variable::_new", XS_Clownfish__CFC__Variable__new, file);
        newXS("Clownfish::CFC::Variable::equals", XS_Clownfish__CFC__Variable_equals, file);
        cv = newXS("Clownfish::CFC::Variable::local_c", XS_Clownfish__CFC__Variable__set_or_get, file);
        XSANY.any_i32 = 4 ;
        cv = newXS("Clownfish::CFC::Variable::local_declaration", XS_Clownfish__CFC__Variable__set_or_get, file);
        XSANY.any_i32 = 8 ;
        cv = newXS("Clownfish::CFC::Variable::global_c", XS_Clownfish__CFC__Variable__set_or_get, file);
        XSANY.any_i32 = 6 ;
        cv = newXS("Clownfish::CFC::Variable::_set_or_get", XS_Clownfish__CFC__Variable__set_or_get, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Clownfish::CFC::Variable::get_type", XS_Clownfish__CFC__Variable__set_or_get, file);
        XSANY.any_i32 = 2 ;
        newXS("Clownfish::CFC::Binding::Core::_new", XS_Clownfish__CFC__Binding__Core__new, file);
        newXS("Clownfish::CFC::Binding::Core::write_all_modified", XS_Clownfish__CFC__Binding__Core_write_all_modified, file);
        newXS("Clownfish::CFC::Binding::Core::Function::func_declaration", XS_Clownfish__CFC__Binding__Core__Function_func_declaration, file);
        newXS("Clownfish::CFC::Binding::Core::Method::typedef_dec", XS_Clownfish__CFC__Binding__Core__Method_typedef_dec, file);
        newXS("Clownfish::CFC::Binding::Core::Method::abstract_method_def", XS_Clownfish__CFC__Binding__Core__Method_abstract_method_def, file);
        newXS("Clownfish::CFC::Binding::Core::Method::callback_dec", XS_Clownfish__CFC__Binding__Core__Method_callback_dec, file);
        newXS("Clownfish::CFC::Binding::Core::Method::callback_def", XS_Clownfish__CFC__Binding__Core__Method_callback_def, file);
        newXS("Clownfish::CFC::Binding::Core::Method::_method_def", XS_Clownfish__CFC__Binding__Core__Method__method_def, file);
        newXS("Clownfish::CFC::Binding::Core::Method::_callback_obj_def", XS_Clownfish__CFC__Binding__Core__Method__callback_obj_def, file);
        newXS("Clownfish::CFC::Binding::Core::Aliases::c_aliases", XS_Clownfish__CFC__Binding__Core__Aliases_c_aliases, file);
        newXS("Clownfish::CFC::Binding::Core::Class::_new", XS_Clownfish__CFC__Binding__Core__Class__new, file);
        newXS("Clownfish::CFC::Binding::Core::Class::to_c", XS_Clownfish__CFC__Binding__Core__Class_to_c, file);
        newXS("Clownfish::CFC::Binding::Core::Class::to_c_header", XS_Clownfish__CFC__Binding__Core__Class_to_c_header, file);
        newXS("Clownfish::CFC::Binding::Core::File::_write_h", XS_Clownfish__CFC__Binding__Core__File__write_h, file);
        newXS("Clownfish::CFC::Parser::new", XS_Clownfish__CFC__Parser_new, file);
        newXS("Clownfish::CFC::Parser::parse", XS_Clownfish__CFC__Parser_parse, file);
        newXS("Clownfish::CFC::Parser::_parse_file", XS_Clownfish__CFC__Parser__parse_file, file);
        newXS("Clownfish::CFC::Parser::set_parcel", XS_Clownfish__CFC__Parser_set_parcel, file);
        newXS("Clownfish::CFC::Parser::set_class_name", XS_Clownfish__CFC__Parser_set_class_name, file);
        newXS("Clownfish::CFC::Parser::set_class_cnick", XS_Clownfish__CFC__Parser_set_class_cnick, file);
        newXS("Clownfish::CFC::Parser::get_parcel", XS_Clownfish__CFC__Parser_get_parcel, file);
    }
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

